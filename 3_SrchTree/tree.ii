

template <typename DataT>
Tree<DataT>::Tree( ) : root_{new NodeT}
{}

template <typename DataT>
Tree<DataT>::Tree( const DataT & data ) : root_{new NodeT{data}},
                                          is_empty_{false},
                                          el_num_{1}
{}

template <typename DataT>
Tree<DataT>::~Tree( )
{
    root_->clear_subtree();
    is_empty_ = true;
}

template <typename DataT>
template <typename FindT>
NodeIt<DataT> Tree<DataT>::find( const FindT & data )
{
    return std::move(NodeIt<DataT> {root_->find(data)});
}

template <typename DataT>
template <typename FindT>
NodeIt<DataT> Tree<DataT>::lower_bound( const FindT & data )
{
    auto beg_p = root_->findmin(),
         cur_p = beg_p;

    int count = el_num_;
    int step;

    while (count > 0 && cur_p)
    {
        cur_p = beg_p;
        step = count / 2;

        for (int i = 0; i < step; ++i)
            cur_p = cur_p->next_;

        if (cur_p->data_ < data)
        {
            beg_p = cur_p = cur_p->next_;
            count -= step + 1;
        }
        else
            count = step;
    }

    return std::move(NodeIt{cur_p});
}

template <typename DataT>
NodeIt<DataT> Tree<DataT>::begin( )
{
    return std::move(NodeIt<DataT> {root_->findmin()});
}

template <typename DataT>
NodeIt<DataT> Tree<DataT>::end( )
{
    return std::move(NodeIt<DataT> {nullptr});
}

template <typename DataT>
void Tree<DataT>::insert( const DataT & data )
{
    ++el_num_;
    if (is_empty_)
    {
        *root_ = Node<DataT> {data};
        is_empty_ = false;
    }
    else
        root_ = root_->insert(data);
}

template <typename DataT>
int Tree<DataT>::depth( )
{
    return std::move(root_->depth());
}

template <typename DataT>
bool Tree<DataT>::is_balanced( )
{
    return std::move(root_->is_balanced());
}

template <typename DataT>
void Tree<DataT>::remove( DataT & to_del )
{
    --el_num_;
    root_ = root_->remove(to_del);
}

template <typename DataT>
void Tree<DataT>::print( )
{
    root_->print();
}

template <typename DataT>
void Tree<DataT>::print_leafs( )
{
    if(root_ == nullptr)
        return;
    root_->print_leafs();
}

template <typename DataT>
void Tree<DataT>::print_lvl( int lvl )
{
    if(root_ == nullptr)
        return;
    root_->print_lvl(lvl);
}

template <typename DataT>
void Tree<DataT>::dump( const std::string &dotname /* = "dump.dot" */,
                        const std::string &pngname /* = "dump.png" */ )
{
    std::ofstream fout;
    fout.open(dotname, std::ios::out);

    if (!fout.is_open())
    {
        std::cout << "Cannot open dump file: " << dotname << "\n";
        return;
    }
    fout << "digraph D {\n";
    if (root_ != nullptr)
        root_->dump(fout);

    fout << "}\n";
    fout.close();

    std::string promt = "dot " + dotname + " -Tpng > " + pngname;
    system(promt.c_str());
}
