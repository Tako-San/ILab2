

template <typename DataT>
Tree<DataT>::Tree( ) : root_{new NodeT}
{}

template <typename DataT>
Tree<DataT>::Tree( const DataT & data ) : root_{new NodeT{data}},
                                          is_empty_{false},
                                          el_num_{1}
{}

template <typename DataT>
Tree<DataT>::~Tree( )
{
    root_->clear_subtree();
    is_empty_ = true;
}

template <typename DataT>
template <typename FindT>
NodeIt<DataT> Tree<DataT>::find( const FindT & data )
{
    return NodeIt<DataT> {root_->find(data)};
}

template <typename DataT>
template <typename FindT>
NodeIt<DataT> Tree<DataT>::lower_bound( const FindT & data )
{
    auto beg_it = root_->findmin(),
         cur_it = beg_it,
         end_it = nullptr;

    int count, step;
    count = el_num_;

    while (count > 0)
    {
        cur_it = beg_it;
        step = count / 2;

        for (int i = 0; i < step; ++i)
            cur_it = cur_it->next();

        if (cur_it->data_ < data)
        {
            cur_it = cur_it->next();
            beg_it = cur_it;
            count -= step + 1;
        }
        else
            count = step;
    }

    return NodeIt{cur_it};

    /*
    auto beg_it = begin(),
         cur_it = begin(),
         end_it = end();

    int count, step;
    count = el_num_;

    while (count > 0)
    {
        cur_it = beg_it;
        step = count / 2;

        for (int i = 0; i < step; ++i)
            ++cur_it;

        if (*cur_it < data)
        {
            beg_it = ++cur_it;
            count -= step + 1;
        }
        else
            count = step;
    }

    return beg_it;
    */
}

template <typename DataT>
NodeIt<DataT> Tree<DataT>::begin( )
{
    return NodeIt<DataT> {root_->findmin()};
}

template <typename DataT>
NodeIt<DataT> Tree<DataT>::end( )
{
    return NodeIt<DataT> {nullptr};
}

template <typename DataT>
void Tree<DataT>::insert( const DataT & data )
{
    ++el_num_;
    if (is_empty_)
    {
        root_->data_ = data;
        is_empty_ = false;
    }
    else
        root_ = root_->insert(data);
}

template <typename DataT>
int Tree<DataT>::depth( )
{
    return root_->depth();
}

template <typename DataT>
bool Tree<DataT>::is_balanced( )
{
    return root_->is_balanced();
}

template <typename DataT>
void Tree<DataT>::remove( DataT & to_del )
{
    --el_num_;
    root_ = root_->remove(to_del);
}

template <typename DataT>
void Tree<DataT>::print( )
{
    root_->print();
}

template <typename DataT>
void Tree<DataT>::print_leafs( )
{
    if(root_ == nullptr)
        return;
    root_->print_leafs();
}

template <typename DataT>
void Tree<DataT>::print_lvl( int lvl )
{
    if(root_ == nullptr)
        return;
    root_->print_lvl(lvl);
}