
template <typename DataT>
Node<DataT>::Node( ) : data_{}
{}

template <typename DataT>
Node<DataT>::Node( const DataT & data, Node<DataT> * prnt ) : data_{data},
                                                              prnt_{prnt}

{}

template <typename DataT>
int Node<DataT>::depth( )
{
    return dpth_;
}

template <typename DataT>
int Node<DataT>::cdepth( )
{
    if (this == nullptr)
        return 0;

    int depth = 1;

    int depth_l = left_->cdepth();
    int depth_r = rght_->cdepth();

    int subtr_max = std::max(depth_l, depth_r);

    depth += subtr_max;

    return depth;
}

template <typename DataT>
int Node<DataT>::diff( )
{
    int dl = left_ == nullptr ? 0 : left_->dpth_;
    int dr = rght_ == nullptr ? 0 : rght_->dpth_;

    return dr - dl;
}

template <typename DataT>
void Node<DataT>::set_depth( )
{
    int dl = left_ == nullptr ? 0 : left_->dpth_;
    int dr = rght_ == nullptr ? 0 : rght_->dpth_;

    dpth_ = std::max(dl, dr) + 1;
}

template <typename DataT>
void Node<DataT>::set_parent( Node<DataT> * prnt )
{
    prnt_ = prnt;

    if (prnt_ == nullptr)
        return;

    if (data_ > prnt->data_)
        prnt_->rght_ = this;
    else if (data_ < prnt->data_)
        prnt_->left_ = this;
}

template <typename DataT>
void Node<DataT>::set_right( Node<DataT> * rght )
{
    rght_ = rght;

    if (rght_ == nullptr)
        return;

    rght_->prnt_ = this;
}

template <typename DataT>
void Node<DataT>::set_left( Node<DataT> * left )
{
    left_ = left;

    if (left_ == nullptr)
        return;

    left_->prnt_ = this;
}

template <typename DataT>
Node<DataT> * Node<DataT>::rot_rt( ) // правый поворот вокруг this
{
    Node * that = left_;
    that->set_parent(prnt_);

    set_left(that->rght_);
    that->set_right(this);

    set_depth();
    that->set_depth();

    return that;
}

template <typename DataT>
Node<DataT> * Node<DataT>::rot_lt( ) // левый поворот вокруг this
{
    Node * that = rght_;
    that->set_parent(prnt_);

    set_right(that->left_);
    that->set_left(this);

    set_depth();
    that->set_depth();

    return that;
}

template <typename DataT>
Node<DataT> * Node<DataT>::balance( ) // балансировка узла this
{
    set_depth();

    int cur_diff = diff();

    if( cur_diff >= 2 )
    {
        if( rght_->diff() < 0 )
            rght_ = rght_->rot_rt();
        return rot_lt();
    }
    else if( cur_diff <= -2 )
    {
        if( left_->diff() > 0  )
            left_ = left_->rot_lt();
        return rot_rt();
    }
    return this; // балансировка не нужна
}

template <typename DataT>
bool Node<DataT>::is_balanced( )
{
    int res = abs(left_->cdepth() - rght_->cdepth()) <= 1 ? true : false;
    return res;
}

template <typename DataT>
Node<DataT> * Node<DataT>::findmin( )
{
    if (left_ == nullptr)
        return this;
    else
        return left_->findmin();
}

template <typename DataT>
Node<DataT> * Node<DataT>::removemin( ) // удаление узла с минимальным ключом из дерева p
{
    if( left_ == nullptr )
    {
        auto * res = rght_;
        delete this;
        return res;
    }

    left_ = left_->removemin();
    return balance();
}

template <typename DataT>
Node<DataT> * Node<DataT>::remove( const DataT & data ) // удаление ключа k из дерева p
{
    if( data < data_ )
        left_ = left_->remove(data);
    else if( data > data_ )
        rght_ = rght_->remove(data);
    else
    {
        auto * q = left_;
        auto * r = rght_;

        delete this;

        if( r == nullptr )
            return q;

        auto * min = r->findmin();
        min->rght_ = r->removemin();
        min->left_ = q;

        return min->balance();
    }
    return balance();
}

template <typename DataT>
template <typename FindT>
Node<DataT> * Node<DataT>::find( const DataT & data )
{
    auto * cur = this;

    while (cur != nullptr)
    {
        if (data == cur->data_)
            return cur;

        if (data > cur->data_)
            cur = cur->rght_;
        else if (data < *cur)
            cur = cur->left_;
        else
            cur = nullptr;
    }

    return cur;
}

template <typename DataT>
Node<DataT> * Node<DataT>::insert( const DataT & data )
{

    if (data > data_)
    {
        if (rght_ != nullptr)
            rght_ = rght_->insert(data);
        else
            rght_ = new Node<DataT>{data, this};
    }
    else if (data < data_)
    {
        if (left_ != nullptr)
            left_ = left_->insert(data);
        else
            left_ = new Node<DataT>{data, this};
    }

    return balance();
}


template <typename DataT>
void Node<DataT>::clear_subtree( )
{
    if(this == nullptr)
        return;

    if(left_!= nullptr)
        left_->clear_subtree();
    if(rght_ != nullptr)
        rght_->clear_subtree();

    delete this;
}

using std::cout;
using std::endl;

template <typename DataT>
void Node<DataT>::print( )
{
    if(left_!= nullptr)
        left_->print();

    if(prnt_ == nullptr)
        cout << data_ << " - ROOT" << endl;
    else if(left_== nullptr && rght_ == nullptr)
        cout << data_ << " - leaf" << endl;
    else
        cout << data_ << endl;

    if(rght_ != nullptr)
        rght_->print();
}


template <typename DataT>
void Node<DataT>::print_leafs( )
{
    if(this == nullptr)
        return;

    if(left_== nullptr && rght_ == nullptr)
        std::cout << data_ <<"\n";
    else
    {
        left_->print_leafs();
        rght_->print_leafs();
    }
}

template <typename DataT>
void Node<DataT>::print_lvl( int lvl )
{
    if(this == nullptr)
        return;
    else if(lvl == 0)
        std::cout << data_ << " ";
    else if(lvl > 0)
    {
        left_->print_lvl(lvl - 1);
        rght_->print_lvl(lvl - 1);
    }
}
