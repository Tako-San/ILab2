
template <typename DataT>
Node<DataT>::Node() : data_()
{}

template <typename DataT>
Node<DataT>::Node( DataT & data ) : data_{data}
{}

template <typename DataT>
const DataT & Node<DataT>::get_data( ) const
{
    return data_;
}

template <typename DataT>
void Node<DataT>::set( const DataT & data, Node<DataT> * prnt )
{
    data_ = data;
    prnt_ = prnt;
}


#define IF_THEN( cond, side_)                \
    if (cond)                                \
    {                                        \
        if (cur->side_ != nullptr)           \
            cur.ptr_ = cur->side_;           \
        else                                 \
        {                                    \
            cur->side_ = new Node;           \
            cur->side_->set(data, cur.ptr_); \
        }                                    \
    }                                        \

template <typename DataT>
NodeIt<DataT> Node<DataT>::add( const DataT & data )
{
    NodeIt<DataT> cur{this};
    
    while (data != *cur)
    {
        IF_THEN(data > *cur, rght_)
        else
        IF_THEN(data < *cur, left_)
    }

    return cur;
}

#undef IF_THEN

template <typename DataT>
template <typename FindT>
NodeIt<DataT> Node<DataT>::find( FindT & data )
{
    NodeIt<DataT> cur{this};

    while (cur.ptr_ != nullptr)
    {
        if (data == *cur)
            return cur;

        if (data > *cur)
            cur.ptr_ = cur->rght_;
        else if (data < *cur)
            cur.ptr_ = cur->left_;
        else
            cur.ptr_ = nullptr;
    }

    return cur;
}

template <typename DataT>
Node<DataT> * Node<DataT>::next( )
{


}

template <typename DataT>
Node<DataT> * Node<DataT>::prev( )
{

}

template <typename DataT>
int Node<DataT>::depth( )
{
    if(this == nullptr)
        return 0;

    int depth = 1;

    int depth_l = left_->depth();
    int depth_r = rght_->depth();

    int subtr_max = (depth_l > depth_r)? depth_l : depth_r;

    depth += subtr_max;

    return depth;
}

template <typename DataT>
bool Node<DataT>::is_balanced( )
{
    int res = abs(left_->depth() - rght_->depth()) <= 1 ? 1 : 0;
    return res;
}

template <typename DataT>
void Node<DataT>::del( DataT to_del )
{
    if (this == nullptr)
        return;
    if (to_del < data_)
        left_->del(to_del);
    else if (to_del > data_)
        rght_->del(to_del);
    else if (left_ != nullptr && rght_ != nullptr)
    {
        Node *tmp;
        for(tmp = rght_; tmp->left_!= nullptr; tmp = tmp->left);
        data_ = tmp->data_;
        rght_->del(data_.key);
    }
    else if (left_ != nullptr)
    {
        Node * tmp = left_;

        if (left_->left_ != nullptr)
            left_->left_->prnt_ = this;
        if (left_->rght_ != nullptr)
            left_->rght_->prnt_ = this;

        data_ = left_->data;

        rght_ = left_->rght_;
        left_= left_->left_;

        delete tmp;
    }
    else if (rght_ != nullptr)
    {
        Node * tmp = rght_;

        if (rght_->rght_ != nullptr)
            rght_->rght_->prnt_ = this;
        if (rght_->left_!= nullptr)
            rght_->left_->prnt_ = this;

        data_ = rght_->data_;

        left_= rght_->left_;
        rght_ = rght_->rght_;

        delete tmp;
    }
    else
    {
        if(prnt_->left_== this)
            prnt_->left_= nullptr;
        else
            prnt_->rght_ = nullptr;
        delete this;
    }
}

template <typename DataT>
void Node<DataT>::clear( )
{
    if(this == nullptr)
        return;

    if(left_!= nullptr)
        left_->clear();
    if(rght_ != nullptr)
        rght_->clear();

    delete this;
}

template <typename DataT>
void Node<DataT>::print( )
{
    if(left_!= nullptr)
        left_->print();

    if(prnt_ == nullptr)
        cout << *this << " - ROOT" << endl;
    else if(left_== nullptr && rght_ == nullptr)
        cout << *this << " - leaf" << endl;
    else
        cout << *this << endl;

    if(rght_ != nullptr)
        rght_->print();
}

template <typename DataT>
void Node<DataT>::print_leafs( )
{
    if(this == nullptr)
        return;

    if(left_== nullptr && rght_ == nullptr)
        std::cout << data_ <<"\n";
    else
    {
        left_->print_leafs();
        rght_->print_leafs();
    }
}


template <typename DataT>
void Node<DataT>::print_lvl( int lvl )
{
    if(this == nullptr)
        return;
    else if(lvl == 0)
        std::cout << *this;
    else if(lvl > 0)
    {
        left_->print_lvl(lvl - 1);
        rght_->print_lvl(lvl - 1);
    }
}




template <typename DataT>
Node<DataT> * NodeIt<DataT>::operator -> ( )
{
    return ptr_;
}

template <typename DataT>
NodeIt<DataT>::NodeIt( Node<DataT> * ptr ) : ptr_{ptr}
{}

template <typename DataT>
NodeIt<DataT>::NodeIt( const NodeIt<DataT> & it ) : ptr_{it.ptr_}
{}

template <typename DataT>
bool NodeIt<DataT>::operator == ( const NodeIt<DataT> & it ) const
{
    return ptr_ == it.ptr_;
}

template <typename DataT>
bool NodeIt<DataT>::operator != ( const NodeIt<DataT> & it ) const
{
    return  ptr_ != it.ptr_;
}

template <typename DataT>
DataT & NodeIt<DataT>::operator * ( )
{
    return ptr_->data_;
}


template <typename DataT>
const DataT & NodeIt<DataT>::operator * ( ) const
{
    return ptr_->data_;
}

template <typename DataT>
NodeIt<DataT> & NodeIt<DataT>::operator ++ ()
{
    ptr_ = ptr_->next();
}

template <typename DataT>
NodeIt<DataT> & NodeIt<DataT>::operator -- ()
{
    ptr_ = ptr_->prev();
}


template <typename DataT>
std::ostream & operator << ( std::ostream & ost, const Node<DataT> & node )
{
    return ost << node.get_data();
}