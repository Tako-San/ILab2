
template <typename DataT>
Node<DataT>::Node( ) : data_{}
{}

template <typename DataT>
Node<DataT>::Node( const DataT & data,
                   Node<DataT> * prnt,
                   Node<DataT> * next,
                   Node<DataT> * prev) : data_{data},
                                         prnt_{prnt},
                                         next_{next},
                                         prev_{prev}
{}

template <typename DataT>
int Node<DataT>::depth( )
{
    return dpth_;
}

template <typename DataT>
int Node<DataT>::diff( )
{
    int dl = (left_ == nullptr) ? 0 : left_->dpth_,
        dr = (rght_ == nullptr) ? 0 : rght_->dpth_;

    return dr - dl;
}

template <typename DataT>
void Node<DataT>::set_depth( )
{
    int dl = (left_ == nullptr) ? 0 : left_->dpth_,
        dr = (rght_ == nullptr) ? 0 : rght_->dpth_;

    dpth_ = std::max(dl, dr) + 1;
}

template <typename DataT>
void Node<DataT>::set_parent( Node<DataT> * prnt )
{
    prnt_ = prnt;

    if (prnt_ == nullptr)
        return;

    if (data_ > prnt->data_)
        prnt_->rght_ = this;
    else if (data_ < prnt->data_)
        prnt_->left_ = this;
}

template <typename DataT>
void Node<DataT>::set_right( Node<DataT> * rght )
{
    rght_ = rght;

    if (rght_ != nullptr)
        rght_->prnt_ = this;
}

template <typename DataT>
void Node<DataT>::set_left( Node<DataT> * left )
{
    left_ = left;

    if (left_ != nullptr)
        left_->prnt_ = this;
}

template <typename DataT>
Node<DataT> * Node<DataT>::rot_rt( ) // правый поворот вокруг this
{
    Node * that = left_;
    that->set_parent(prnt_);

    set_left(that->rght_);
    that->set_right(this);

    set_depth();
    that->set_depth();

    return that;
}

template <typename DataT>
Node<DataT> * Node<DataT>::rot_lt( ) // левый поворот вокруг this
{
    Node * that = rght_;
    that->set_parent(prnt_);

    set_right(that->left_);
    that->set_left(this);

    set_depth();
    that->set_depth();

    return that;
}

template <typename DataT>
Node<DataT> * Node<DataT>::balance( ) // балансировка узла this
{
    set_depth();

    int cur_diff = diff();

    if( cur_diff >= 2 )
    {
        if( rght_->diff() < 0 )
            rght_ = rght_->rot_rt();
        return rot_lt();
    }
    else if( cur_diff <= -2 )
    {
        if( left_->diff() > 0  )
            left_ = left_->rot_lt();
        return rot_rt();
    }
    return this; // балансировка не нужна
}

template <typename DataT>
bool Node<DataT>::is_balanced( )
{
    return abs(diff()) <= 1;
}

template <typename DataT>
Node<DataT> * Node<DataT>::findmin( )
{
    Node<DataT> * cur{};
    for (cur = this; cur->left_ != nullptr; cur = cur->left_);
    return cur;
}

template <typename DataT>
Node<DataT> * Node<DataT>::findmax( )
{
    Node<DataT> * cur{};
    for (cur = this; cur->rght_ != nullptr; cur = cur->rght_);
    return cur;
}

template <typename DataT>
Node<DataT> * Node<DataT>::removemin( ) // удаление узла с минимальным ключом из дерева p
{
    if( left_ == nullptr )
    {
        auto * res = rght_;
        delete this;
        return res;
    }

    left_ = left_->removemin();
    return balance();
}

template <typename DataT>
Node<DataT> * Node<DataT>::remove( const DataT & data ) // удаление ключа k из дерева p
{
    if( data < data_ )
        left_ = left_->remove(data);
    else if( data > data_ )
        rght_ = rght_->remove(data);
    else
    {
        auto * q = left_;
        auto * r = rght_;

        if (prev_)
            prev_->next_ = next_;
        if (next_)
            next_->prev_ = prev_;

        delete this;

        if( r == nullptr )
            return q;

        auto * min = r->findmin();
        min->rght_ = r->removemin();
        min->left_ = q;

        return min->balance();
    }
    return balance();
}

template <typename DataT>
template <typename FindT>
Node<DataT> * Node<DataT>::find( const FindT & data )
{
    auto * cur = this;

    while (cur != nullptr)
    {
        if (data == cur->data_)
            return cur;

        if (data > cur->data_)
            cur = cur->rght_;
        else if (data < cur->data_)
            cur = cur->left_;
        else
            cur = nullptr;
    }

    return cur;
}

template <typename DataT>
Node<DataT> * Node<DataT>::insert( const DataT & data )
{
    auto cur = this;

    while(data != cur->data_)
        if (data > cur->data_)
        {
            if (cur->rght_ == nullptr)
            {
                auto & new_node = cur->rght_;
                new_node = new Node<DataT>{data, cur, cur->next_, cur};

                if (cur->next_)
                    cur->next_->prev_ = new_node;

                cur->next_ = new_node;
                break;
            }
            else
                cur = cur->rght_;
        }
        else
        {
            if (cur->left_ == nullptr)
            {
                auto & new_node = cur->left_;
                new_node = new Node<DataT>{data, cur, cur, cur->prev_};

                if (cur->prev_)
                    cur->prev_->next_ = new_node;

                cur->prev_ = new_node;
                break;
            }
            else
                cur = cur->left_;
        }

    while (cur != this)
    {
        cur = cur->balance();
        cur = cur->prnt_;
    }

    return balance();
}


template <typename DataT>
void Node<DataT>::clear_subtree( )
{
    if(this == nullptr)
        return;

    if(left_!= nullptr)
        left_->clear_subtree();

    if(rght_ != nullptr)
        rght_->clear_subtree();

    delete this;
}

using std::cout;
using std::endl;

template <typename DataT>
void Node<DataT>::print( )
{
    if(left_!= nullptr)
        left_->print();

    if(prnt_ == nullptr)
        cout << data_ << " - ROOT" << endl;
    else if(left_== nullptr && rght_ == nullptr)
        cout << data_ << " - leaf" << endl;
    else
        cout << data_ << endl;

    if(rght_ != nullptr)
        rght_->print();
}


template <typename DataT>
void Node<DataT>::print_leafs( )
{
    if(this == nullptr)
        return;

    if(left_== nullptr && rght_ == nullptr)
        std::cout << data_ <<"\n";
    else
    {
        left_->print_leafs();
        rght_->print_leafs();
    }
}

template <typename DataT>
void Node<DataT>::print_lvl( int lvl )
{
    if(this == nullptr)
        return;
    else if(lvl == 0)
        std::cout << data_ << " ";
    else if(lvl > 0)
    {
        left_->print_lvl(lvl - 1);
        rght_->print_lvl(lvl - 1);
    }
}

template <typename DataT>
void Node<DataT>::dump( std::ofstream &oft )
{
    if (left_ != nullptr)
    {
        oft << data_ << " -> " << left_->data_ << ";\n";
        left_->dump(oft);
    }

    if (rght_ != nullptr)
    {
        oft << data_ << " -> " << rght_->data_ << " [style=dashed];\n";
        rght_->dump(oft);
    }

    /*if (next_ != nullptr)
        oft << data_ << " -> " << next_->data_ << " [color=red];\n";

    if (prev_ != nullptr)
        oft << data_ << " -> " << prev_->data_ << " [color=blue];\n";*/

    oft << data_ << ";\n";
}



template <typename DataT>
NodeIt<DataT>::NodeIt( const NodeIt<DataT> & it ) : ptr_{it.ptr_}
{}

template <typename DataT>
NodeIt<DataT>::NodeIt( Node<DataT> * ptr ) : ptr_{ptr}
{}

template <typename DataT>
NodeIt<DataT> & NodeIt<DataT>::operator = ( const NodeIt<DataT> & it )
{
    ptr_ = it.ptr_;
    return *this;
}

template <typename DataT>
bool NodeIt<DataT>::operator == ( const NodeIt<DataT> & it ) const
{
    return (ptr_ == it.ptr_);
}

template <typename DataT>
bool NodeIt<DataT>::operator != ( const NodeIt<DataT> & it ) const
{
    return (ptr_ != it.ptr_);
}

template <typename DataT>
DataT & NodeIt<DataT>::operator * ( )
{
    return ptr_->data_;
}

template <typename DataT>
const DataT & NodeIt<DataT>::operator * ( ) const
{
    return ptr_->data_;
}

template <typename DataT>
NodeIt<DataT> & NodeIt<DataT>::operator ++ ()
{
    ptr_ = ptr_->next_;
    return *this;
}

template <typename DataT>
NodeIt<DataT> & NodeIt<DataT>::operator -- ()
{
    ptr_ = ptr_->prev_;
    return *this;
}